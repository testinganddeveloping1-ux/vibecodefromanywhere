# Security Debug + Pentest Playbook (Authorized Scope)

This playbook is for debug-mode workers and orchestrators validating security defects safely.

Use this for:
- `security-threat-model`
- `security-vuln-repro`
- `security-remediation`
- `dependency-risk-audit`

Do not use this for unauthorized targeting.

## 1) Scope and Safety Gate

Before any testing, require:
- Target owner authorization.
- Explicit in-scope systems/files.
- Approved test window.
- Isolation boundary (local sandbox, staging, or intentionally vulnerable lab).
- Incident contact if disruption occurs.

Required preflight statement:

```text
AUTHORIZATION: confirmed
TARGET_SCOPE: <repos/services/hosts>
OUT_OF_SCOPE: <everything else>
ENVIRONMENT: isolated lab/staging
STOP_CONDITIONS: data risk / availability risk / unexpected lateral movement
```

## 2) Threat Modeling First (No Blind Scanning)

Minimum threat-model packet:
- Assets: credentials, session tokens, PII, payment flows, privileged endpoints.
- Entry points: web/API routes, upload paths, webhook handlers, auth callbacks, admin tooling.
- Trust boundaries: browser->API, API->DB, service->service, queue consumers, background workers.
- Abuse paths: privilege escalation, data exfiltration, command injection, auth bypass.
- Existing controls: authZ checks, input validation, rate limits, audit logs.

Prioritize by:
- Exploitability in current architecture.
- Impact if exploited (confidentiality/integrity/availability).
- Detectability and rollback difficulty.

## 3) Vulnerability Classes to Validate

Use classes (OWASP/CWE aligned):
- Injection (SQL, command, template, expression).
- Broken authentication/session management.
- Broken access control / object-level authorization.
- Cryptographic misuse / secret exposure.
- Insecure deserialization / parser abuse.
- SSRF and outbound request abuse.
- Path traversal and unsafe file operations.
- Business logic abuse (state transitions, duplicate/partial operations).
- Race conditions in auth/payment/checkout/update flows.
- Dependency vulnerabilities reachable by your runtime paths.

## 4) Safe Reproduction Workflow

Use in this order:
1. Reproduce expected secure behavior.
2. Reproduce suspected vulnerable behavior using minimal payloads.
3. Confirm impact with non-destructive checks.
4. Capture deterministic evidence (request/response, logs, test output).
5. Stop before destructive actions.

Evidence packet format:

```text
BUG:
ROOT:
FIX_PLAN:
TEST_BEFORE:
TEST_AFTER:
RESIDUAL_RISK:
```

## 5) Controlled Exploitability Validation

Allowed in this playbook:
- Demonstrating bypass in isolated lab.
- Demonstrating privilege boundary break with test accounts.
- Demonstrating data access boundary break using synthetic data only.

Not allowed:
- Production destructive payloads.
- Data deletion/modification outside synthetic test fixtures.
- Persistence, lateral movement, or stealth tactics.

Use “proof of exploitability” patterns that are reversible and safe:
- Access denied becomes access granted on test resource.
- Invalid token accepted unexpectedly in staging.
- Input escapes parser and reaches dangerous sink in controlled harness.

## 6) Root Cause Analysis

Map symptom -> invariant -> root cause.

Examples:
- Symptom: user can read another account’s object.
  - Invariant: object ownership must match authenticated subject.
  - Root cause: missing ownership check in one code path.
- Symptom: input executes shell.
  - Invariant: untrusted input must never reach command execution sink.
  - Root cause: unsanitized interpolation into shell command.

Always identify:
- Failing file and function.
- Why existing control did not cover path.
- Similar sibling paths needing audit.

## 7) Remediation Patterns

Access control:
- Centralize authorization checks.
- Deny by default.
- Validate subject-resource relation on every object read/write path.

Injection:
- Use parameterized queries only.
- Remove shell composition where possible.
- Strict allowlist input validation at trust boundaries.

Session/auth:
- Rotate and invalidate tokens on privilege-sensitive changes.
- Enforce secure cookie/token properties.
- Prevent token confusion across services.

File/path safety:
- Canonicalize + constrain path to allowed root.
- Reject traversal attempts explicitly.
- Avoid dynamic eval/template execution on untrusted content.

Concurrency/integrity:
- Add idempotency keys and uniqueness guards.
- Enforce transaction boundaries on multi-step updates.
- Add row-level or logical locks where needed.

## 8) Security Regression Testing Matrix

For every confirmed security defect:
- Add at least one negative test (attack attempt must fail).
- Add one positive test (normal flow still works).
- Add one boundary test around the fixed condition.
- Add one sibling-path test for likely bypass variants.

Command evidence examples:
- targeted security tests
- integration tests for auth boundaries
- full regression subset for touched modules

Completion requires:
- Fail before fix.
- Pass after fix.
- No new regressions in neighboring security-critical paths.

## 9) Dependency and Supply-Chain Checks

When running `dependency-risk-audit`:
- Identify vulnerable package and reachable code path.
- Confirm exploitability in your runtime context.
- Prefer minimal patch version bump first.
- Validate lockfile and transitive changes.
- Record rollback plan if patch breaks compatibility.

Track:
- Advisory source.
- Introduced version and fixed version.
- Exploit preconditions.
- Runtime exposure.

## 10) Reporting Contract for Orchestrator

Security worker must report:
- `BUG`: what is vulnerable and impact tier.
- `ROOT`: exact failing invariant and code path.
- `FIX`: minimal mitigation and why it closes exploit path.
- `TEST`: command outputs for before/after.
- `RESULT`: residual risk and recommended next controls.

Orchestrator approval criteria:
- Scope authorized.
- Reproduction evidence concrete.
- Fix targets root cause, not symptom masking.
- Regression tests included.
- Rollback trigger defined.

## 11) Escalation Rules

Escalate to orchestrator/user immediately when:
- Potential exposure of real customer data.
- Auth bypass affecting admin or cross-tenant boundaries.
- Fix requires broad architectural changes.
- Security control uncertainty remains after two verification cycles.

## 12) Quick Checklist

- [ ] Authorization and scope confirmed.
- [ ] Threat model packet produced.
- [ ] Vulnerability reproduced safely in lab/staging.
- [ ] Root cause identified with file-level precision.
- [ ] Minimal mitigation implemented.
- [ ] Security regression tests added.
- [ ] Before/after evidence captured.
- [ ] Rollback trigger and residual risk documented.

## 13) Open-Source Reference Set

Use these as baseline standards when expanding this playbook:
- OWASP Web Security Testing Guide (WSTG)
- OWASP ASVS
- OWASP Cheat Sheet Series (auth, input validation, SSRF, deserialization, SQLi)
- CWE Top categories for root-cause classification
- NIST SSDF for secure development lifecycle checkpoints
