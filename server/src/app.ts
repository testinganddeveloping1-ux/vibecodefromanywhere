import Fastify from "fastify";
import helmet from "@fastify/helmet";
import compress from "@fastify/compress";
import websocket from "@fastify/websocket";
import type { FastifyInstance } from "fastify";
import type { WebSocket } from "ws";
import cookie from "@fastify/cookie";
import staticPlugin from "@fastify/static";
import path from "node:path";
import fs from "node:fs";
import { fileURLToPath } from "node:url";
import { addAuthGuard } from "./auth.js";
import { SessionManager, type ToolCommand, type ToolId } from "./sessions/session_manager.js";
import { createStore, type Store } from "./store.js";
import { configDir, configPath, defaultConfig, parseConfigToml, type Config } from "./config.js";
import { macroToWrites } from "./macros/macro_engine.js";
import { isUnderRoot, listDir, normalizeRoots, validateCwd } from "./workspaces.js";
import { ToolDetector } from "./tools/detector.js";
import { buildArgsForSession } from "./tools/arg_builders.js";
import { execCapture } from "./tools/exec.js";
import { PairingManager } from "./pairing.js";
import { resolveGitForPath, listGitWorktrees } from "./git.js";
import { nanoid } from "nanoid";
import { createHash, randomUUID } from "node:crypto";
import { ToolSessionIndex } from "./tool_sessions.js";

export type AppConfig = {
  token: string;
  tools?: Record<ToolId, ToolCommand>;
  dataDir?: string;
  profiles?: Config["profiles"];
  workspaces?: Config["workspaces"];
  hookBaseUrl?: string;
};

export async function buildApp(cfg: AppConfig): Promise<FastifyInstance> {
  const app = Fastify({
    logger: false,
    bodyLimit: 10 * 1024 * 1024,
  });

  const disableHelmet = process.env.FYP_DISABLE_HELMET === "1" || process.env.FYP_DISABLE_HELMET === "true";
  const disableCompress = process.env.FYP_DISABLE_COMPRESS === "1" || process.env.FYP_DISABLE_COMPRESS === "true";

  if (!disableHelmet) await app.register(helmet, { contentSecurityPolicy: false });
  if (!disableCompress) await app.register(compress);
  await app.register(websocket);
  await app.register(cookie);

  // Protect API + websocket only; UI assets can load and show the unlock screen.
  addAuthGuard(app, cfg.token, { onlyPrefixes: ["/api", "/ws"], exceptPrefixes: ["/api/auth/pair/claim"] });

  const baseDir = cfg.dataDir ?? configDir();
  const hookBaseUrl = cfg.hookBaseUrl ?? `http://127.0.0.1:7337`;
  const tools = cfg.tools ?? defaultConfig().tools;
  let profiles = cfg.profiles ?? defaultConfig().profiles;
  const roots = normalizeRoots(cfg.workspaces?.roots ?? defaultConfig().workspaces.roots);
  const store = createStore(baseDir);
  const toolIndex = new ToolSessionIndex({ roots });
  const sessions = new SessionManager({ token: cfg.token, tools });
  const detector = new ToolDetector(tools);
  const pairing = new PairingManager();
  const claudeHooksEnabled = !(process.env.FYP_DISABLE_CLAUDE_HOOKS === "1" || process.env.FYP_DISABLE_CLAUDE_HOOKS === "true");

  // Claude Code PermissionRequest hook bridge:
  // - Hook script (runs locally) POSTs PermissionRequest details here.
  // - We surface it as an Inbox item with touch-friendly options.
  // - The hook script polls for the chosen decision and prints it to Claude.
  const claudeHookSessions = new Map<string, { key: string }>(); // sessionId -> key
  const claudeHookRequests = new Map<
    string,
    { sessionId: string; attentionId: number; createdAt: number; decision: any | null; deliveredAt: number | null }
  >(); // signature -> record

  function ensureClaudePermissionHookScript(): string | null {
    const hooksDir = path.join(baseDir, "hooks");
    const hookPath = path.join(hooksDir, "claude_permission_hook.mjs");
    const expected = `#!/usr/bin/env node
// Generated by FromYourPhone. Bridges Claude Code PermissionRequest hooks into FYP Inbox.
// If this script fails or times out, Claude falls back to its normal permission UI.

import { setTimeout as sleep } from "node:timers/promises";

function readStdin() {
  return new Promise((resolve) => {
    let buf = "";
    let done = false;
    const finish = () => {
      if (done) return;
      done = true;
      resolve(buf);
    };
    process.stdin.setEncoding("utf8");
    process.stdin.on("data", (d) => (buf += d));
    process.stdin.on("end", finish);
    process.stdin.on("close", finish);
    // Safety: don't hang forever if stdin never closes. This should be plenty for the small JSON payload.
    setTimeout(finish, 2000).unref?.();
  });
}

async function main() {
  const baseUrl = process.env.FYP_HOOK_BASE_URL || "";
  const key = process.env.FYP_HOOK_KEY || "";
  const sessionId = process.env.FYP_SESSION_ID || "";
  const timeoutMs = Number(process.env.FYP_HOOK_TIMEOUT_MS || "540000"); // 9m
  if (!baseUrl || !key || !sessionId || !Number.isFinite(timeoutMs) || timeoutMs < 10_000) return;

  const raw = String(await readStdin());
  let payload = null;
  try {
    payload = JSON.parse(raw);
  } catch {
    return;
  }
  if (!payload || typeof payload !== "object") return;

  let signature = "";
  try {
    const r = await fetch(baseUrl.replace(/\\/$/, "") + "/hooks/claude/permission-request", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        "x-fyp-hook-key": key,
      },
      body: JSON.stringify({ sessionId, payload }),
    });
    if (!r.ok) return;
    const j = await r.json();
    signature = typeof j?.signature === "string" ? j.signature : "";
    if (!signature) return;
  } catch {
    return;
  }

  const deadline = Date.now() + timeoutMs;
  while (Date.now() < deadline) {
    try {
      const u =
        baseUrl.replace(/\\/$/, "") +
        "/hooks/claude/permission-decision?sessionId=" +
        encodeURIComponent(sessionId) +
        "&signature=" +
        encodeURIComponent(signature);
      const r = await fetch(u, { headers: { "x-fyp-hook-key": key } });
      if (r.status === 404) return;
      if (r.ok) {
        const j = await r.json();
        const decision = j?.decision ?? null;
        if (decision && typeof decision === "object") {
          const out = {
            hookSpecificOutput: {
              hookEventName: "PermissionRequest",
              decision,
            },
          };
          process.stdout.write(JSON.stringify(out) + "\\n");
          return;
        }
      }
    } catch {
      // ignore
    }
    await sleep(350);
  }
}

main().catch(() => {});
`;

    try {
      fs.mkdirSync(hooksDir, { recursive: true });
      const cur = fs.existsSync(hookPath) ? fs.readFileSync(hookPath, "utf8") : "";
      if (cur !== expected) fs.writeFileSync(hookPath, expected, { encoding: "utf8", mode: 0o755 });
      try {
        fs.chmodSync(hookPath, 0o755);
      } catch {
        // ignore
      }
    } catch {
      // ignore
    }
    return fs.existsSync(hookPath) ? hookPath : null;
  }

  function shQuote(s: string): string {
    // POSIX single-quote safe. We don't target Windows here.
    return `'${String(s).replace(/'/g, `'\\''`)}'`;
  }

  function claudePermissionSignature(sessionId: string, toolName: string, toolInput: any): string {
    const h = createHash("sha256").update(JSON.stringify({ toolName, toolInput })).digest("hex").slice(0, 16);
    return `${sessionId}|claude.permission|${toolName}|${h}`;
  }

  function summarizeClaudePermission(toolName: string, toolInput: any): { severity: "info" | "warn" | "danger"; title: string; body: string } {
    const t = String(toolName || "Tool");
    const lower = t.toLowerCase();
    const severity: "info" | "warn" | "danger" =
      lower.includes("bash") || lower.includes("shell") || lower.includes("command") ? "danger" : lower.includes("write") || lower.includes("edit") ? "warn" : "info";

    let body = "";
    try {
      if (lower === "bash" || lower.includes("bash")) {
        const cmd = typeof toolInput?.command === "string" ? toolInput.command : "";
        body = cmd ? `$ ${cmd}` : "Claude wants to run a shell command.";
      } else if (lower.includes("write") || lower.includes("edit")) {
        const fp = typeof toolInput?.file_path === "string" ? toolInput.file_path : typeof toolInput?.path === "string" ? toolInput.path : "";
        body = fp ? fp : "Claude wants to write/edit files.";
      } else if (lower.includes("read")) {
        const fp = typeof toolInput?.file_path === "string" ? toolInput.file_path : typeof toolInput?.path === "string" ? toolInput.path : "";
        body = fp ? fp : "Claude wants to read files.";
      } else {
        body = JSON.stringify(toolInput ?? {}).slice(0, 520);
      }
    } catch {
      body = "Claude is requesting permission.";
    }
    const title = `Claude permission: ${t}`;
    return { severity, title, body };
  }

  function hasBearerAuth(req: any): boolean {
    const auth = String(req?.headers?.authorization ?? "");
    if (!auth.toLowerCase().startsWith("bearer ")) return false;
    const tok = auth.slice("bearer ".length).trim();
    return Boolean(tok) && tok === cfg.token;
  }

  function hasClaudeHookKey(req: any, sessionId: string): boolean {
    const raw = (req?.headers as any)?.["x-fyp-hook-key"];
    const key = typeof raw === "string" ? raw : Array.isArray(raw) ? String(raw[0] ?? "") : "";
    if (!key) return false;
    const rec = claudeHookSessions.get(sessionId);
    return Boolean(rec && rec.key === key);
  }

  function authHook(req: any, sessionId: string): boolean {
    return hasBearerAuth(req) || hasClaudeHookKey(req, sessionId);
  }

  // Cleanup: avoid unbounded growth if something goes wrong.
  setInterval(() => {
    const now = Date.now();
    for (const [sig, r] of claudeHookRequests.entries()) {
      if (now - r.createdAt > 30 * 60 * 1000) claudeHookRequests.delete(sig);
      else if (r.deliveredAt && now - r.deliveredAt > 20_000) claudeHookRequests.delete(sig);
    }
  }, 60_000).unref?.();

  app.post("/hooks/claude/permission-request", async (req, reply) => {
    const body = (req.body ?? {}) as any;
    const sessionId = typeof body?.sessionId === "string" ? body.sessionId : "";
    const payload = body?.payload ?? null;
    if (!sessionId || !payload) return reply.code(400).send({ ok: false, reason: "bad_request" });
    if (!authHook(req, sessionId)) return reply.code(401).send({ ok: false, reason: "unauthorized" });
    const sess = store.getSession(sessionId);
    if (!sess || sess.tool !== "claude") return reply.code(404).send({ ok: false, reason: "session_not_found" });

    const toolName = typeof (payload as any)?.tool_name === "string" ? (payload as any).tool_name : "Tool";
    const toolInput = (payload as any)?.tool_input ?? {};
    const suggestions = Array.isArray((payload as any)?.permission_suggestions) ? (payload as any).permission_suggestions : [];

    const signature = claudePermissionSignature(sessionId, toolName, toolInput);
    const summary = summarizeClaudePermission(toolName, toolInput);

    const options: any[] = [
      { id: "y", label: "Allow once", decision: { behavior: "allow" } },
    ];
    // Surface suggestions as separate "Always allow" buttons.
    for (let i = 0; i < suggestions.length; i++) {
      const s = suggestions[i];
      const type = typeof s?.type === "string" ? s.type : "suggestion";
      const tool = typeof s?.tool === "string" ? s.tool : toolName;
      const label =
        type === "toolAlwaysAllow"
          ? `Always allow ${tool}`
          : `Always allow (${type})`;
      options.push({ id: `a${i + 1}`, label, decision: { behavior: "allow", updatedPermissions: [s] } });
    }
    options.push({ id: "n", label: "Deny", decision: { behavior: "deny" } });

    const created = store.createAttentionItem({
      sessionId,
      kind: "claude.permission",
      severity: summary.severity,
      title: summary.title,
      body: summary.body,
      signature,
      options,
    });
    const attentionId = created.ok ? created.id : created.existingId ?? -1;

    // Track for polling.
    claudeHookRequests.set(signature, {
      sessionId,
      attentionId,
      createdAt: Date.now(),
      decision: null,
      deliveredAt: null,
    });

    log("claude hook PermissionRequest", { sessionId, toolName, attentionId });
    broadcastGlobal({ type: "inbox.changed", sessionId });
    return { ok: true, signature, attentionId };
  });

  app.get("/hooks/claude/permission-decision", async (req, reply) => {
    const q = req.query as any;
    const sessionId = typeof q?.sessionId === "string" ? q.sessionId : "";
    const signature = typeof q?.signature === "string" ? q.signature : "";
    if (!sessionId || !signature) return reply.code(400).send({ ok: false, reason: "bad_request" });
    if (!authHook(req, sessionId)) return reply.code(401).send({ ok: false, reason: "unauthorized" });
    const rec = claudeHookRequests.get(signature);
    if (!rec || rec.sessionId !== sessionId) return reply.code(404).send({ ok: false, reason: "unknown_signature" });
    if (rec.decision) {
      rec.deliveredAt = Date.now();
      return { ok: true, decision: rec.decision };
    }
    return { ok: true, decision: null };
  });

  // Serve UI assets from dist no matter what directory the server is launched from.
  // When compiled, this file lives at `dist/server/app.js`, so `../web` is `dist/web`.
  const moduleDir = path.dirname(fileURLToPath(import.meta.url));
  const webRootCandidates = [
    path.join(moduleDir, "..", "web"),
    path.join(process.cwd(), "dist", "web"),
  ];
  const webRoot = webRootCandidates.find((p) => fs.existsSync(p)) ?? webRootCandidates[1]!;
  if (fs.existsSync(webRoot)) {
    await app.register(staticPlugin, { root: webRoot, prefix: "/", decorateReply: false });
    app.setNotFoundHandler(async (_req, reply) => {
      const indexPath = path.join(webRoot, "index.html");
      reply.type("text/html").send(fs.readFileSync(indexPath, "utf8"));
    });
  }

  // Broadcast: sessionId -> sockets
  const sockets = new Map<string, Set<WebSocket>>();
  const globalSockets = new Set<WebSocket>();

  // Plaintext buffers (for lightweight prompt detection, especially for Codex when --no-alt-screen is enabled).
  const textBuf = new Map<string, string>();
  const lastPreview = new Map<string, { ts: number; line: string }>();
  const lastPreviewBroadcast = new Map<string, number>();
  const lastInboxBroadcast = new Map<string, number>();
  const assistState = new Map<string, { sig: string; assist: any | null }>();
  const worktreeCache = new Map<string, { ts: number; items: any[]; root: string }>();
  const debugWs = process.env.FYP_DEBUG_WS === "1" || process.env.FYP_DEBUG_WS === "true";
  const wsLog = (...args: any[]) => {
    if (debugWs) console.log("[fyp/ws]", ...args);
  };
  const verboseLog = process.env.FYP_LOG === "1" || process.env.FYP_LOG === "true";
  const log = (...args: any[]) => {
    if (!verboseLog) return;
    try {
      console.log("[fyp]", ...args);
    } catch {
      // ignore
    }
  };

  // Buffer DB writes for output chunks so heavy terminal output doesn't stall the UI.
  const outputBuf = new Map<string, { chunks: string[]; bytes: number; timer: any }>();
  function flushOutput(sessionId: string) {
    const rec = outputBuf.get(sessionId);
    if (!rec || rec.chunks.length === 0) return;
    if (rec.timer) {
      clearTimeout(rec.timer);
      rec.timer = null;
    }
    const joined = rec.chunks.join("");
    rec.chunks = [];
    rec.bytes = 0;
    try {
      store.appendOutput(sessionId, joined);
    } catch {
      // ignore
    }
  }
  function queueOutput(sessionId: string, chunk: string) {
    const rec = outputBuf.get(sessionId) ?? { chunks: [], bytes: 0, timer: null };
    rec.chunks.push(chunk);
    rec.bytes += chunk.length;
    outputBuf.set(sessionId, rec);
    if (rec.bytes > 96_000 || rec.chunks.length > 120) {
      flushOutput(sessionId);
      return;
    }
    if (!rec.timer) {
      rec.timer = setTimeout(() => flushOutput(sessionId), 90);
    }
  }

  function stripAnsi(s: string): string {
    // Minimal ANSI stripper: good enough for prompt detection. We keep it dependency-free.
    // eslint-disable-next-line no-control-regex
    return s
      .replace(/\u001b\[[0-9;?]*[ -/]*[@-~]/g, "")
      // OSC (ESC ]) can be terminated by BEL (\u0007) or ST (ESC \\).
      .replace(/\u001b\][\s\S]*?(?:\u0007|\u001b\\)/g, "")
      // DCS (ESC P) uses ST (ESC \\) terminator.
      .replace(/\u001bP[\s\S]*?\u001b\\/g, "");
  }

  function updatePlainBuffer(sessionId: string, chunk: string): string {
    const prev = textBuf.get(sessionId) ?? "";
    const next = (prev + stripAnsi(chunk)).slice(-80_000);
    textBuf.set(sessionId, next);
    return next;
  }

  function updateLastLine(sessionId: string, chunk: string) {
    const plain = stripAnsi(chunk).replace(/\r/g, "");
    const parts = plain.split("\n");
    for (let i = parts.length - 1; i >= 0; i--) {
      const ln = parts[i]!.trim();
      if (!ln) continue;
      lastPreview.set(sessionId, { ts: Date.now(), line: ln.slice(0, 220) });
      return;
    }
  }

  function wsSend(s: WebSocket, payload: unknown) {
    try {
      s.send(JSON.stringify(payload));
    } catch {
      // ignore
    }
  }

  function setAssist(sessionId: string, assist: any | null) {
    const sig = assist && typeof assist.signature === "string" ? assist.signature : "";
    const prev = assistState.get(sessionId)?.sig ?? "";
    if (sig === prev) return;
    assistState.set(sessionId, { sig, assist });
    const set = sockets.get(sessionId);
    if (!set) return;
    for (const sock of set) wsSend(sock, { type: "assist", assist, ts: Date.now() });
  }

  function attachBroadcast(sessionId: string, tool: ToolId) {
    sessions.onOutput(sessionId, (chunk) => {
      queueOutput(sessionId, chunk);
      updateLastLine(sessionId, chunk);
      const buf = updatePlainBuffer(sessionId, chunk);
      const tail = buf.slice(-9000);

      // Light global preview updates (throttled).
      const lastTs = lastPreviewBroadcast.get(sessionId) ?? 0;
      if (Date.now() - lastTs > 900) {
        const p = lastPreview.get(sessionId);
        if (p?.line) {
          lastPreviewBroadcast.set(sessionId, Date.now());
          broadcastGlobal({ type: "session.preview", sessionId, line: p.line, ts: p.ts });
        }
      }

      // Lightweight Codex approval detection. Best with `codex --no-alt-screen`.
      // We do not spam: signature dedupe is enforced in the store.
      if (tool === "codex") {
        const cand = detectCodexAttention(sessionId, tail);
        if (cand) {
          store.createAttentionItem(cand);
          // Throttle broadcasts so the phone UI updates even when we touch/refresh an existing item.
          const last = lastInboxBroadcast.get(sessionId) ?? 0;
          if (Date.now() - last > 900) {
            lastInboxBroadcast.set(sessionId, Date.now());
            broadcastGlobal({ type: "inbox.changed", sessionId });
          }
        }
      }

      // TUI Assist: best-effort option/menu detection for touch-friendly buttons on phones.
      // This is intentionally generic (not tool-specific), so it survives small TUI text changes.
      try {
        const assist = detectTuiAssist(tail);
        setAssist(sessionId, assist);
      } catch {
        // ignore
      }

      const set = sockets.get(sessionId);
      if (!set) return;
      for (const sock of set) wsSend(sock, { type: "output", chunk, ts: Date.now() });
    });
  }

  function attachExitTracking(sessionId: string) {
    sessions.onExit(sessionId, (st) => {
      try {
        flushOutput(sessionId);
        try {
          store.setSessionExit(sessionId, st.exitCode ?? null, st.signal ?? null);
        } catch {
          // ignore
        }
        let evId = -1;
        try {
          evId = store.appendEvent(sessionId, "session.exit", { exitCode: st.exitCode ?? null, signal: st.signal ?? null });
        } catch {
          evId = -1;
        }
        log("session exit", { sessionId, exitCode: st.exitCode ?? null, signal: st.signal ?? null });
        if (evId !== -1) {
          broadcastEvent(sessionId, {
            id: evId,
            ts: Date.now(),
            kind: "session.exit",
            data: { exitCode: st.exitCode ?? null, signal: st.signal ?? null },
          });
        }
        broadcastGlobal({ type: "sessions.changed" });
        broadcastGlobal({ type: "workspaces.changed" });
      } catch {
        // ignore
      } finally {
        // Best-effort cleanup to avoid unbounded memory growth if many sessions are spawned.
        outputBuf.delete(sessionId);
        textBuf.delete(sessionId);
        assistState.delete(sessionId);
        lastPreview.delete(sessionId);
        lastPreviewBroadcast.delete(sessionId);
        lastInboxBroadcast.delete(sessionId);
        claudeHookSessions.delete(sessionId);
        for (const [sig, r] of claudeHookRequests.entries()) {
          if (r.sessionId === sessionId) claudeHookRequests.delete(sig);
        }
      }
    });
  }

  function broadcastGlobal(payload: unknown) {
    for (const sock of globalSockets) wsSend(sock, payload);
  }

  function broadcastEvent(sessionId: string, evt: { id: number; ts: number; kind: string; data: unknown }) {
    const set = sockets.get(sessionId);
    if (!set) return;
    const payload = { type: "event", event: evt };
    for (const sock of set) wsSend(sock, payload);
  }

  function detectCodexAttention(sessionId: string, text: string): null | {
    sessionId: string;
    kind: string;
    severity: "info" | "warn" | "danger";
    title: string;
    body: string;
    signature: string;
    options: any;
  } {
    // Titles + option labels from Codex TUI source:
    // - "Would you like to run the following command?"
    // - "Would you like to make the following edits?"
    // - "Do you want to approve access to \"<host>\"?"
    // - "<server> needs your approval."
    // Options commonly have shortcuts: y / a / p / n / Esc / c (mcp cancel)
    const t = text;

    // Network approval
    const mHost = t.match(/Do you want to approve access to "([^"]+)"\?/);
    if (mHost?.[1]) {
      const host = mHost[1];
      const title = `Network access: ${host}`;
      const signature = `${sessionId}|codex.approval|net|${host}`;
      const options = [
        { id: "y", label: "Yes, just this once (Y)", send: "y" },
        { id: "a", label: "Yes, allow this host for session (A)", send: "a" },
        { id: "n", label: "No, tell Codex what to do (N / Esc)", send: "n" },
        { id: "esc", label: "Esc", send: "\u001b" },
      ];
      return {
        sessionId,
        kind: "codex.approval",
        severity: "danger",
        title,
        body: "Codex is requesting network access.",
        signature,
        options,
      };
    }

    // Exec approval
    if (t.includes("Would you like to run the following command?")) {
      // Best-effort snippet extraction: look for first "$ ..." line after the title.
      const mCmd = t.match(/Would you like to run the following command\\?[\\s\\S]{0,800}?\\$\\s*([^\\n\\r]{1,180})/);
      const cmd = mCmd?.[1]?.trim() ?? "";
      const title = "Run command approval";
      const signature = `${sessionId}|codex.approval|exec|${cmd || "unknown"}`;
      const hasPrefixOpt = t.includes("don't ask again for commands that start with `");
      const options = [
        { id: "y", label: "Yes, proceed (Y)", send: "y" },
        ...(hasPrefixOpt ? [{ id: "p", label: "Yes, don't ask again for this prefix (P)", send: "p" }] : []),
        { id: "n", label: "No, tell Codex what to do (N / Esc)", send: "n" },
        { id: "esc", label: "Esc", send: "\u001b" },
      ];
      return {
        sessionId,
        kind: "codex.approval",
        severity: "warn",
        title,
        body: cmd ? `$ ${cmd}` : "Codex wants to run a command.",
        signature,
        options,
      };
    }

    // Patch approval
    if (t.includes("Would you like to make the following edits?")) {
      const signature = `${sessionId}|codex.approval|patch`;
      const options = [
        { id: "y", label: "Yes, proceed (Y)", send: "y" },
        { id: "a", label: "Yes, don't ask again for these files (A)", send: "a" },
        { id: "n", label: "No, tell Codex what to do (N / Esc)", send: "n" },
        { id: "esc", label: "Esc", send: "\u001b" },
      ];
      return {
        sessionId,
        kind: "codex.approval",
        severity: "warn",
        title: "Apply edits approval",
        body: "Codex produced edits and is asking to apply them.",
        signature,
        options,
      };
    }

    // MCP elicitation approval
    const mMcp = t.match(/\\b([^\\n\\r]{1,60}) needs your approval\\./);
    if (mMcp?.[1]) {
      const serverName = mMcp[1].trim();
      const signature = `${sessionId}|codex.approval|mcp|${serverName}`;
      const options = [
        { id: "y", label: "Yes, provide requested info (Y)", send: "y" },
        { id: "n", label: "No, continue without it (N)", send: "n" },
        { id: "c", label: "Cancel request (C / Esc)", send: "c" },
        { id: "esc", label: "Esc", send: "\u001b" },
      ];
      return {
        sessionId,
        kind: "codex.approval",
        severity: "info",
        title: `MCP approval: ${serverName}`,
        body: "A tool/server is requesting approval.",
        signature,
        options,
      };
    }

    return null;
  }

  function detectTuiAssist(text: string): null | { title: string; body: string | null; options: any[]; signature: string } {
    // Generic prompt/menu detector for touch UIs:
    // - Extracts the most recent question-ish line (title)
    // - Extracts option hotkeys like "(Y) Yes", "1) Foo", "[A] Allow"
    // - Emits a stable signature so the UI can update without spamming
    const raw = String(text ?? "").replace(/\r/g, "");
    if (!raw.trim()) return null;

    const linesAll = raw.split("\n");
    const lines = linesAll.slice(Math.max(0, linesAll.length - 90)).map((l) => String(l ?? "").trimEnd());
    while (lines.length && !lines[lines.length - 1]!.trim()) lines.pop();
    if (!lines.length) return null;

    const opts: { id: string; label: string; send: string }[] = [];
    const seen = new Set<string>();
    const pushOpt = (send: string, label: string) => {
      const s = String(send ?? "");
      const l = String(label ?? "").trim();
      if (!s || !l) return;
      if (seen.has(s)) return;
      if (opts.length >= 10) return;
      seen.add(s);
      opts.push({ id: s, label: l.length > 60 ? l.slice(0, 60) : l, send: s });
    };

    const parseOptionLine = (ln: string) => {
      const line = ln.trim();
      if (!line) return;

      // Inline: "... (Y) Yes (N) No ..."
      const inlineRe = /\(([A-Za-z0-9])\)\s*([A-Za-z][^()]{0,50})/g;
      let m: RegExpExecArray | null = null;
      // eslint-disable-next-line no-cond-assign
      while ((m = inlineRe.exec(line))) {
        const key = String(m[1] ?? "").trim();
        const label = String(m[2] ?? "").trim().replace(/^[,;:\-]+/, "").trim();
        if (!key || !label) continue;
        pushOpt(key.toLowerCase(), label);
      }

      // [Y] Yes
      const b = line.match(/^\s*\[([A-Za-z0-9])\]\s*(.{2,80})\s*$/);
      if (b?.[1] && b?.[2]) pushOpt(String(b[1]).toLowerCase(), String(b[2]));

      // (Y) Yes
      const p = line.match(/^\s*\(([A-Za-z0-9])\)\s*(.{2,80})\s*$/);
      if (p?.[1] && p?.[2]) pushOpt(String(p[1]).toLowerCase(), String(p[2]));

      // Y) Yes
      const r = line.match(/^\s*([A-Za-z0-9])\)\s*(.{2,80})\s*$/);
      if (r?.[1] && r?.[2]) pushOpt(String(r[1]).toLowerCase(), String(r[2]));

      // 1) Foo / 1. Foo
      const n = line.match(/^\s*([0-9]{1,2})[.)]\s*(.{2,80})\s*$/);
      if (n?.[1] && n?.[2]) pushOpt(String(n[1]), String(n[2]));

      // y/n quick prompt (no labels). We map to Yes/No.
      if (/\b[yY]\/[nN]\b/.test(line) || /\b[nN]\/[yY]\b/.test(line)) {
        pushOpt("y", "Yes");
        pushOpt("n", "No");
      }
    };

    // Scan recent lines for options.
    const scanStart = Math.max(0, lines.length - 34);
    for (let i = scanStart; i < lines.length; i++) parseOptionLine(lines[i]!);

    // Also surface common navigation hints as single-tap buttons when they appear in the text.
    // Keep this conservative to avoid showing the overlay during normal terminal output.
    const lowTail = lines.slice(scanStart).join("\n").toLowerCase();
    const hadChoices = opts.length > 0;
    const hasShiftTab = /\bshift\s*[\+\- ]?\s*tab\b/.test(lowTail) || lowTail.includes("shift-tab");
    const hasPressTab = /\b(?:press|hit)\s+tab\b/.test(lowTail);
    const hasPressEnter = /\b(?:press|hit)\s+enter\b/.test(lowTail);
    const hasPressEsc = /\b(?:press|hit)\s+(?:esc|escape)\b/.test(lowTail);
    const hasArrowKeys = /\barrow\s+keys\b/.test(lowTail);

    if (!hadChoices && !hasShiftTab && !hasPressTab && !hasPressEnter && !hasPressEsc && !hasArrowKeys) return null;

    if (hasShiftTab) pushOpt("\u001b[Z", "Shift+Tab");
    if (hasPressTab || hasShiftTab) pushOpt("\t", "Tab");
    if (hasPressEnter) pushOpt("\r", "Enter");
    if (hasPressEsc || (hadChoices && /\b(?:esc|escape)\b/.test(lowTail))) pushOpt("\u001b", "Esc");
    if (hasArrowKeys) {
      pushOpt("\u001b[A", "Up");
      pushOpt("\u001b[B", "Down");
      pushOpt("\r", "Enter");
    }

    if (opts.length === 0) return null;

    // Pick a reasonable title.
    let title = "";
    let body: string | null = null;
    for (let i = lines.length - 1; i >= 0 && lines.length - i <= 42; i--) {
      const ln = lines[i]!.trim();
      if (!ln) continue;
      if (ln.length > 220) continue;
      if (ln.includes("?") || /^(select|choose|pick|press|permission|mode|sandbox|approval)\b/i.test(ln)) {
        title = ln;
        break;
      }
      if (!title) title = ln;
    }
    title = title ? title.slice(0, 140) : "TUI";

    for (let i = lines.length - 1; i >= 0 && lines.length - i <= 30; i--) {
      const ln = lines[i]!.trim();
      if (!ln) continue;
      const low = ln.toLowerCase();
      if (low.includes("arrow") || low.includes("shift+tab") || low.includes("escape") || low.includes("press enter")) {
        body = ln.slice(0, 240);
        break;
      }
    }

    const sig = createHash("sha256")
      .update(JSON.stringify({ title, body, options: opts.map((o) => ({ id: o.id, label: o.label })) }))
      .digest("hex")
      .slice(0, 16);

    return { title, body, options: opts, signature: `assist:${sig}` };
  }

  function scheduleCodexToolSessionLink(fypSessionId: string, cwd: string, createdAt: number) {
    // Codex does not let us set the session UUID ahead of time, so we discover it by scanning
    // the ~/.codex/sessions logs shortly after spawn.
    const maxAttempts = 10;
    const baseDelayMs = 250;
    const stepMs = 450;

    const attempt = (n: number) => {
      const delay = baseDelayMs + n * stepMs + Math.floor(Math.random() * 80);
      setTimeout(() => {
        try {
          const cur = store.getSession(fypSessionId);
          if (!cur) return;
          if (cur.toolSessionId) return;

          const items = toolIndex
            .list({ refresh: true })
            .filter((s) => s.tool === "codex" && s.cwd === cwd)
            .sort((a, b) => b.updatedAt - a.updatedAt);

          const cutoff = createdAt - 12_000;
          const recent = items.filter((s) => Number(s.createdAt ?? s.updatedAt) >= cutoff);
          const cand = recent[0] ?? null;

          if (!cand) {
            if (n + 1 < maxAttempts) attempt(n + 1);
            return;
          }

          // Avoid linking two FYP sessions to the same Codex session id.
          const dup = store.listSessions().find((s) => s.id !== fypSessionId && s.toolSessionId === cand.id) ?? null;
          if (dup) {
            if (n + 1 < maxAttempts) attempt(n + 1);
            return;
          }

          store.setSessionToolSessionId(fypSessionId, cand.id);
          const evId = store.appendEvent(fypSessionId, "session.tool_link", { tool: "codex", toolSessionId: cand.id });
          if (evId !== -1) {
            broadcastEvent(fypSessionId, { id: evId, ts: Date.now(), kind: "session.tool_link", data: { tool: "codex", toolSessionId: cand.id } });
          }
          broadcastGlobal({ type: "sessions.changed" });
          broadcastGlobal({ type: "workspaces.changed" });
        } catch {
          // ignore
        }
      }, delay).unref?.();
    };

    attempt(0);
  }

  // Pairing: generate short code so you donâ€™t have to paste long tokens.
  app.post("/api/auth/pair/start", async () => {
    const rec = pairing.start();
    return { ok: true, code: rec.code, expiresAt: rec.expiresAt };
  });

  // No auth required. Exchange a short-lived code for the httpOnly cookie.
  app.post("/api/auth/pair/claim", async (req, reply) => {
    const body = (req.body ?? {}) as any;
    const code = typeof body.code === "string" ? body.code : "";
    const r = pairing.claim(code);
    if (!r.ok) return reply.code(400).send({ ok: false, reason: r.reason });
    reply.setCookie("fyp_token", cfg.token, {
      httpOnly: true,
      sameSite: "lax",
      path: "/",
      maxAge: 60 * 60 * 24 * 30,
    });
    return { ok: true };
  });

  app.get("/api/doctor", async () => {
    const caps = await detector.get();
    return {
      ok: true,
      scannedAt: caps.scannedAt,
      tools: caps,
      store: store.doctor(),
      workspaceRoots: roots,
    };
  });

  app.post("/api/doctor/rescan", async () => {
    const caps = await detector.scan();
    return {
      ok: true,
      scannedAt: caps.scannedAt,
      tools: caps,
      store: store.doctor(),
      workspaceRoots: roots,
    };
  });

  // OpenCode helpers: list available models. Useful for phone UI model picker.
  const opencodeModelsCache = new Map<string, { ts: number; items: string[] }>();
  app.get("/api/opencode/models", async (req, reply) => {
    const q = (req.query ?? {}) as any;
    const provider = typeof q?.provider === "string" ? q.provider.trim() : "";
    const refresh = q?.refresh === "1" || q?.refresh === "true" || q?.refresh === "yes";
    const key = provider || "*";

    try {
      const caps = await detector.get();
      if (!caps.opencode.installed) return reply.code(400).send({ ok: false, error: "tool_not_installed" });
    } catch {
      // ignore
    }

    const cached = !refresh ? opencodeModelsCache.get(key) : null;
    const maxAgeMs = 5 * 60 * 1000;
    if (cached && Date.now() - cached.ts < maxAgeMs) {
      return { ok: true, provider: provider || null, cached: true, items: cached.items };
    }

    const spec = tools.opencode;
    const args = [...spec.args, "models"];
    if (provider) args.push(provider);
    if (refresh) args.push("--refresh");
    const r = await execCapture(spec.command, args, { timeoutMs: refresh ? 20_000 : 8_000 });
    if (!r.ok) {
      const msg = (r.stderr || r.stdout || r.error || "").trim().slice(0, 420);
      return reply.code(400).send({ ok: false, error: "models_failed", message: msg || "failed to list models" });
    }

    const items = stripAnsi(r.stdout)
      .split("\n")
      .map((s) => s.trim())
      .filter(Boolean)
      // Defensive: filter out accidental log lines.
      .filter((s) => !s.startsWith("INFO ") && !s.startsWith("WARN ") && !s.startsWith("ERROR "));

    opencodeModelsCache.set(key, { ts: Date.now(), items });
    return { ok: true, provider: provider || null, cached: false, items };
  });

  app.get("/api/config", async () => {
    const safeProfiles = Object.entries(profiles).map(([id, p]) => ({
      id,
      tool: p.tool,
      title: p.title,
      sendSuffix: p.sendSuffix,
    }));
    return {
      ok: true,
      tools: Object.keys(tools),
      profiles: safeProfiles,
      workspaceRoots: roots,
    };
  });

  app.get("/api/config/raw", async () => {
    return { toml: fs.readFileSync(configPath(), "utf8") };
  });

  app.put("/api/config/raw", async (req, reply) => {
    const body = (req.body ?? {}) as any;
    const toml = typeof body.toml === "string" ? body.toml : "";
    if (!toml.trim()) return reply.code(400).send({ error: "empty" });
    let next: Config;
    try {
      next = parseConfigToml(toml);
    } catch (e: any) {
      return reply.code(400).send({ error: "parse_failed", message: typeof e?.message === "string" ? e.message : "" });
    }
    fs.writeFileSync(configPath(), toml, "utf8");
    profiles = next.profiles ?? profiles;
    return { ok: true };
  });

  app.get("/api/fs/list", async (req, reply) => {
    const q = req.query as any;
    const p = typeof q?.path === "string" ? q.path : roots[0] ?? process.cwd();
    const showHidden = q?.showHidden === "1" || q?.showHidden === "true" || q?.showHidden === "yes";
    const r = listDir(p, roots, { showHidden });
    if (!r.ok) return reply.code(400).send({ error: "bad_path", reason: r.reason });
    return r;
  });

  app.get("/api/workspaces/recent", async (req) => {
    const q = req.query as any;
    const limit = Number(q?.limit ?? 10);
    return { ok: true, items: store.listRecentWorkspaces(limit) };
  });

  app.get("/api/workspaces", async () => {
    const sess = store.listSessions();
    const counts = store.getOpenAttentionCounts();

    type Ws = {
      key: string;
      root: string;
      isGit: boolean;
      trees: any[];
      sessions: any[];
      lastUsed: number;
    };

    const byKey = new Map<string, Ws>();
    for (const s of sess) {
      const key = s.workspaceKey ? String(s.workspaceKey) : `dir:${s.cwd ?? s.id}`;
      const root = s.workspaceRoot || s.treePath || s.cwd || "";
      const ws: Ws =
        byKey.get(key) ??
        ({
          key,
          root,
          isGit: Boolean(s.workspaceKey),
          trees: [],
          sessions: [],
          lastUsed: 0,
        } as Ws);

      ws.lastUsed = Math.max(ws.lastUsed, Number(s.updatedAt ?? 0));
      ws.sessions.push({
        id: s.id,
        tool: s.tool,
        profileId: s.profileId,
        toolSessionId: s.toolSessionId ?? null,
        cwd: s.cwd,
        treePath: s.treePath,
        workspaceKey: s.workspaceKey,
        workspaceRoot: s.workspaceRoot,
        label: s.label,
        pinnedSlot: s.pinnedSlot,
        createdAt: s.createdAt,
        updatedAt: s.updatedAt,
        running: sessions.getStatus(s.id)?.running ?? false,
        attention: counts[s.id] ?? 0,
        preview: lastPreview.get(s.id)?.line ?? null,
      });
      byKey.set(key, ws);
    }

    const items = Array.from(byKey.values()).sort((a, b) => b.lastUsed - a.lastUsed);

    // Attach tree lists for git workspaces (cached).
    for (const w of items) {
      if (!w.isGit) continue;
      const any = w.sessions.find((x) => typeof x.treePath === "string" && x.treePath) ?? w.sessions[0];
      const anyRoot = String(any?.treePath || any?.cwd || w.root || "");
      if (!anyRoot) continue;
      const cached = worktreeCache.get(w.key);
      if (cached && Date.now() - cached.ts < 6000) {
        w.trees = cached.items;
        continue;
      }
      const r = await listGitWorktrees(anyRoot);
      if (r.ok) {
        w.trees = r.items;
        worktreeCache.set(w.key, { ts: Date.now(), items: r.items as any[], root: anyRoot });
      } else {
        w.trees = [];
      }
    }

    return { ok: true, items };
  });

  app.get("/api/workspaces/preset", async (req, reply) => {
    const q = req.query as any;
    const p = typeof q?.path === "string" ? q.path : "";
    const tool = q?.tool as ToolId;
    if (!p) return reply.code(400).send({ error: "bad_path" });
    if (tool !== "codex" && tool !== "claude" && tool !== "opencode") return reply.code(400).send({ error: "bad_tool" });
    const vv = validateCwd(p, roots);
    if (!vv.ok) return reply.code(400).send({ error: "bad_path", reason: vv.reason });
    // Prefer exact directory presets, but fall back to git-workspace presets so
    // worktrees share defaults (Codex-like "workspace" behavior).
    let rec = store.getWorkspacePreset(vv.cwd, tool);
    if (!rec) {
      try {
        const gr = await resolveGitForPath(vv.cwd);
        if (gr.ok) {
          rec =
            store.getWorkspacePreset(gr.workspaceKey, tool) ??
            store.getWorkspacePreset(gr.workspaceRoot, tool) ??
            null;
        }
      } catch {
        // ignore
      }
    }
    return { ok: true, preset: rec };
  });

  app.put("/api/workspaces/preset", async (req, reply) => {
    const body = (req.body ?? {}) as any;
    const p = typeof body?.path === "string" ? body.path : "";
    const tool = body?.tool as ToolId;
    const profileId = typeof body?.profileId === "string" ? body.profileId : "";
    const overrides = body?.overrides ?? {};
    if (!p || !profileId) return reply.code(400).send({ error: "bad_request" });
    if (tool !== "codex" && tool !== "claude" && tool !== "opencode") return reply.code(400).send({ error: "bad_tool" });
    const vv = validateCwd(p, roots);
    if (!vv.ok) return reply.code(400).send({ error: "bad_path", reason: vv.reason });
    store.upsertWorkspacePreset({ path: vv.cwd, tool, profileId, overrides });
    try {
      const gr = await resolveGitForPath(vv.cwd);
      if (gr.ok) {
        store.upsertWorkspacePreset({ path: gr.workspaceKey, tool, profileId, overrides });
      }
    } catch {
      // ignore
    }
    broadcastGlobal({ type: "workspaces.changed" });
    return { ok: true };
  });

  // Tool-native session discovery (Codex + Claude).
  // This powers chat-history rendering and lets the phone UI resume/fork sessions created outside FYP.
  app.get("/api/tool-sessions", async (req, reply) => {
    const q = (req.query ?? {}) as any;
    const tool = typeof q?.tool === "string" ? String(q.tool).trim() : "";
    const under = typeof q?.under === "string" ? String(q.under).trim() : "";
    const refresh = q?.refresh === "1" || q?.refresh === "true" || q?.refresh === "yes";

    let items = toolIndex.list({ refresh });
    if (tool === "codex" || tool === "claude") items = items.filter((s) => s.tool === tool);

    if (under) {
      const vv = validateCwd(under, roots);
      if (!vv.ok) return reply.code(400).send({ error: "bad_path", reason: vv.reason });
      const root = vv.cwd;
      items = items.filter((s) => isUnderRoot(s.cwd, root));
    }

    return { ok: true, items };
  });

  app.get("/api/tool-sessions/:tool/:id/messages", async (req, reply) => {
    const params = (req.params ?? {}) as any;
    const tool = params.tool as any;
    const id = typeof params.id === "string" ? String(params.id) : "";
    const q = (req.query ?? {}) as any;
    const refresh = q?.refresh === "1" || q?.refresh === "true" || q?.refresh === "yes";
    const limit = Number(q?.limit ?? 160);
    if (tool !== "codex" && tool !== "claude") return reply.code(400).send({ error: "bad_tool" });
    if (!id) return reply.code(400).send({ error: "bad_id" });

    const sess = toolIndex.get(tool, id, { refresh });
    if (!sess) return reply.code(404).send({ error: "not_found" });
    const messages = toolIndex.getMessages(tool, id, { refresh, limit });
    return { ok: true, session: sess, messages: messages ?? [] };
  });

  app.get("/api/inbox", async (req) => {
    const q = req.query as any;
    const limit = Number(q?.limit ?? 120);
    const workspaceKeyRaw = typeof q?.workspaceKey === "string" ? q.workspaceKey : null;
    const workspaceKey =
      workspaceKeyRaw && !workspaceKeyRaw.startsWith("dir:") ? workspaceKeyRaw : null;
    const cwd =
      workspaceKeyRaw && workspaceKeyRaw.startsWith("dir:") ? workspaceKeyRaw.slice("dir:".length) : null;
    const sessionId = typeof q?.sessionId === "string" ? q.sessionId : null;
    const items = store.listInbox({ limit, workspaceKey, cwd, sessionId });
    const out = items.map((it) => ({
      ...it,
      session: store.getSession(it.sessionId),
    }));
    return { ok: true, items: out };
  });

  app.post("/api/inbox/:id/respond", async (req, reply) => {
    const id = Number((req.params as any).id);
    if (!Number.isFinite(id)) return reply.code(400).send({ error: "bad_id" });
    const body = (req.body ?? {}) as any;
    const optionId = typeof body.optionId === "string" ? body.optionId : "";
    const item = store.getAttentionItem(id);
    if (!item) return reply.code(404).send({ error: "not_found" });
    const sess = store.getSession(item.sessionId);
    if (!sess) return reply.code(404).send({ error: "session_not_found" });
    const opts = Array.isArray(item.options) ? item.options : [];
    const opt = opts.find((o: any) => String(o?.id) === optionId) ?? null;
    const send = opt && typeof opt.send === "string" ? opt.send : "";
    const decision = opt && typeof opt.decision === "object" ? opt.decision : null;
    if (!send && !decision) return reply.code(400).send({ error: "bad_option" });

    if (send) {
      try {
        sessions.write(item.sessionId, send);
      } catch (e: any) {
        return reply.code(400).send({ error: "write_failed", message: String(e?.message ?? "write failed") });
      }
    } else if (decision) {
      // Claude hook: store the decision for the polling hook script.
      const rec = claudeHookRequests.get(item.signature);
      if (rec) rec.decision = decision;
      else claudeHookRequests.set(item.signature, { sessionId: item.sessionId, attentionId: id, createdAt: Date.now(), decision, deliveredAt: null });
    }

    const evId = store.appendEvent(item.sessionId, "inbox.respond", { attentionId: id, optionId, send });
    broadcastEvent(item.sessionId, { id: evId, ts: Date.now(), kind: "inbox.respond", data: { attentionId: id, optionId, send } });
    store.addAttentionAction({ attentionId: id, sessionId: item.sessionId, action: "respond", data: { optionId } });
    store.setAttentionStatus(id, "sent");
    broadcastGlobal({ type: "inbox.changed", sessionId: item.sessionId });
    return { ok: true, event: { id: evId, ts: Date.now(), kind: "inbox.respond", data: { attentionId: id, optionId, send } } };
  });

  app.post("/api/inbox/:id/dismiss", async (req, reply) => {
    const id = Number((req.params as any).id);
    if (!Number.isFinite(id)) return reply.code(400).send({ error: "bad_id" });
    const item = store.getAttentionItem(id);
    if (!item) return reply.code(404).send({ error: "not_found" });
    const evId = store.appendEvent(item.sessionId, "inbox.dismiss", { attentionId: id });
    broadcastEvent(item.sessionId, { id: evId, ts: Date.now(), kind: "inbox.dismiss", data: { attentionId: id } });
    store.addAttentionAction({ attentionId: id, sessionId: item.sessionId, action: "dismiss", data: {} });
    store.setAttentionStatus(id, "dismissed");
    broadcastGlobal({ type: "inbox.changed", sessionId: item.sessionId });
    return { ok: true, event: { id: evId, ts: Date.now(), kind: "inbox.dismiss", data: { attentionId: id } } };
  });

  app.get("/api/sessions", async () => {
    const counts = store.getOpenAttentionCounts();
    return store.listSessions().map((s) => ({
      ...s,
      running: sessions.getStatus(s.id)?.running ?? false,
      attention: counts[s.id] ?? 0,
      preview: lastPreview.get(s.id)?.line ?? null,
    }));
  });

  app.delete("/api/sessions/:id", async (req, reply) => {
    const id = (req.params as any).id as string;
    const sess = store.getSession(id);
    if (!sess) return reply.code(404).send({ ok: false, error: "not_found" });

    const st = sessions.getStatus(id);
    if (st?.running) return reply.code(409).send({ ok: false, error: "running" });

    // Remove from the in-memory session manager as well (frees PTY refs).
    try {
      sessions.forget(id);
    } catch {
      // ignore
    }

    // Flush any buffered output chunks for this session before deleting DB rows.
    try {
      flushOutput(id);
    } catch {
      // ignore
    }

    try {
      store.deleteSession(id);
    } catch (e: any) {
      return reply.code(500).send({ ok: false, error: "delete_failed", message: String(e?.message ?? "delete_failed") });
    }

    // Close and forget session websockets, if any.
    try {
      const set = sockets.get(id);
      if (set) {
        for (const sock of set) {
          try {
            sock.close();
          } catch {
            // ignore
          }
        }
      }
      sockets.delete(id);
    } catch {
      // ignore
    }

    // Best-effort cleanup for memory caches.
    try {
      outputBuf.delete(id);
      textBuf.delete(id);
      assistState.delete(id);
      lastPreview.delete(id);
      lastPreviewBroadcast.delete(id);
      lastInboxBroadcast.delete(id);
      claudeHookSessions.delete(id);
      for (const [sig, r] of claudeHookRequests.entries()) {
        if (r.sessionId === id) claudeHookRequests.delete(sig);
      }
    } catch {
      // ignore
    }

    broadcastGlobal({ type: "sessions.changed" });
    broadcastGlobal({ type: "workspaces.changed" });
    broadcastGlobal({ type: "inbox.changed", sessionId: id });
    return { ok: true };
  });

  app.post("/api/sessions", async (req, reply) => {
    const body = (req.body ?? {}) as any;
    const tool = body.tool as ToolId;
    const profileId = typeof body.profileId === "string" ? body.profileId : `${tool}.default`;
    const requestedCwd = typeof body.cwd === "string" ? body.cwd : null;
    const savePreset = typeof body.savePreset === "boolean" ? body.savePreset : true;
    const toolActionRaw = typeof body.toolAction === "string" ? body.toolAction : null;
    const toolAction = toolActionRaw === "resume" || toolActionRaw === "fork" ? toolActionRaw : null;
    const toolSessionId = typeof body.toolSessionId === "string" ? body.toolSessionId.trim() : "";
    const wantsToolSession = Boolean(toolAction && toolSessionId);

    if ((toolActionRaw || toolSessionId) && !wantsToolSession) {
      return reply.code(400).send({ error: "bad_tool_session" });
    }
    if (wantsToolSession && tool !== "codex" && tool !== "claude") {
      return reply.code(400).send({ error: "unsupported", field: "toolAction", value: toolAction });
    }
    if (tool !== "codex" && tool !== "claude" && tool !== "opencode") {
      return reply.code(400).send({ error: "invalid tool" });
    }

    const caps = await detector.get();
    const toolCaps =
      tool === "codex" ? caps.codex : tool === "claude" ? caps.claude : caps.opencode;
    if (!(toolCaps as any).installed) return reply.code(400).send({ error: "tool_not_installed" });

    let toolSess: any | null = null;
    if (wantsToolSession) {
      toolSess = toolIndex.get(tool as any, toolSessionId, { refresh: false }) ?? toolIndex.get(tool as any, toolSessionId, { refresh: true });
      if (!toolSess) return reply.code(404).send({ error: "tool_session_not_found" });
    }

    const desiredCwd = requestedCwd ?? (toolSess?.cwd ?? null);
    const cwdOk = desiredCwd ? validateCwd(desiredCwd, roots) : null;
    if (cwdOk && !cwdOk.ok) return reply.code(400).send({ error: "bad_cwd", reason: cwdOk.reason });
    let cwd = cwdOk && cwdOk.ok ? cwdOk.cwd : undefined;
    if (!cwd) {
      const v = validateCwd(process.cwd(), roots);
      cwd = v.ok ? v.cwd : roots[0] ?? process.cwd();
    }

    const profile = profiles[profileId];
    const extraEnv: Record<string, string> = {};

    // Profile-provided env
    if (profile && profile.tool === tool) {
      if ((profile as any).env && typeof (profile as any).env === "object") {
        for (const [k, v] of Object.entries((profile as any).env as any)) extraEnv[String(k)] = String(v);
      }
    }

    const overrides = (body.overrides ?? {}) as any;

    // Merge profile tool-native settings with per-session overrides.
    const effectiveProfile =
      profile && profile.tool === tool
        ? (structuredClone(profile) as any)
        : ({
            tool,
            title: `${tool} (custom)`,
            startup: [],
            sendSuffix: "\r",
          } as any);

    function readDirs(v: any): string[] {
      if (!Array.isArray(v)) return [];
      return v.map((x) => String(x)).filter(Boolean);
    }

    function validateDirsOr400(dirs: string[]): { ok: true; dirs: string[] } | { ok: false; resp: any } {
      const out: string[] = [];
      for (const d of dirs) {
        const vv = validateCwd(d, roots);
        if (!vv.ok) return { ok: false, resp: reply.code(400).send({ error: "bad_dir", dir: d, reason: vv.reason }) as any };
        out.push(vv.cwd);
      }
      return { ok: true, dirs: Array.from(new Set(out)) };
    }

    if (tool === "codex") {
      effectiveProfile.codex = effectiveProfile.codex ?? {};
      const o = overrides.codex ?? {};
      if (typeof o.sandbox === "string") effectiveProfile.codex.sandbox = o.sandbox;
      if (typeof o.askForApproval === "string") effectiveProfile.codex.askForApproval = o.askForApproval;
      if (typeof o.fullAuto === "boolean") effectiveProfile.codex.fullAuto = o.fullAuto;
      if (typeof o.bypassApprovalsAndSandbox === "boolean")
        effectiveProfile.codex.bypassApprovalsAndSandbox = o.bypassApprovalsAndSandbox;
      if (typeof o.search === "boolean") effectiveProfile.codex.search = o.search;
      if (typeof o.noAltScreen === "boolean") effectiveProfile.codex.noAltScreen = o.noAltScreen;
      const mergedDirs = [
        ...(effectiveProfile.codex.addDir ?? []),
        ...readDirs(o.addDir),
      ];
      const vd = validateDirsOr400(mergedDirs);
      if (!vd.ok) return vd.resp;
      effectiveProfile.codex.addDir = vd.dirs;

      if (effectiveProfile.codex.sandbox && !caps.codex.sandboxModes.includes(effectiveProfile.codex.sandbox)) {
        return reply.code(400).send({ error: "unsupported", field: "codex.sandbox", value: effectiveProfile.codex.sandbox });
      }
      if (
        effectiveProfile.codex.askForApproval &&
        !caps.codex.approvalPolicies.includes(effectiveProfile.codex.askForApproval)
      ) {
        return reply
          .code(400)
          .send({ error: "unsupported", field: "codex.askForApproval", value: effectiveProfile.codex.askForApproval });
      }

      if (typeof effectiveProfile.codex.noAltScreen === "boolean" && effectiveProfile.codex.noAltScreen) {
        if (!caps.codex.supports.noAltScreen) {
          return reply.code(400).send({ error: "unsupported", field: "codex.noAltScreen", value: true });
        }
      }
    }

    if (tool === "claude") {
      effectiveProfile.claude = effectiveProfile.claude ?? {};
      const o = overrides.claude ?? {};
      if (typeof o.permissionMode === "string") effectiveProfile.claude.permissionMode = o.permissionMode;
      if (typeof o.dangerouslySkipPermissions === "boolean")
        effectiveProfile.claude.dangerouslySkipPermissions = o.dangerouslySkipPermissions;
      const mergedDirs = [
        ...(effectiveProfile.claude.addDir ?? []),
        ...readDirs(o.addDir),
      ];
      const vd = validateDirsOr400(mergedDirs);
      if (!vd.ok) return vd.resp;
      effectiveProfile.claude.addDir = vd.dirs;

      if (
        effectiveProfile.claude.permissionMode &&
        caps.claude.permissionModes.length > 0 &&
        !caps.claude.permissionModes.includes(effectiveProfile.claude.permissionMode)
      ) {
        return reply
          .code(400)
          .send({ error: "unsupported", field: "claude.permissionMode", value: effectiveProfile.claude.permissionMode });
      }
    }

    if (tool === "opencode") {
      effectiveProfile.opencode = effectiveProfile.opencode ?? {};
      const o = overrides.opencode ?? {};
      if (typeof o.model === "string") effectiveProfile.opencode.model = o.model;
      if (typeof o.agent === "string") effectiveProfile.opencode.agent = o.agent;
      if (typeof o.prompt === "string") effectiveProfile.opencode.prompt = o.prompt;
      if (typeof o.continue === "boolean") effectiveProfile.opencode.continue = o.continue;
      if (typeof o.session === "string") effectiveProfile.opencode.session = o.session;
      if (typeof o.fork === "boolean") effectiveProfile.opencode.fork = o.fork;
      if (typeof o.hostname === "string") effectiveProfile.opencode.hostname = o.hostname;
      if (typeof o.port === "number") effectiveProfile.opencode.port = o.port;
    }

    // Link FYP sessions to tool-native session IDs so we can render chat history.
    // - Claude: we can force a deterministic UUID with --session-id for new sessions.
    // - Codex: we discover the created session log shortly after spawn.
    let toolSessionIdForStore: string | null = null;
    if (wantsToolSession) toolSessionIdForStore = toolSessionId;
    else if (tool === "claude") toolSessionIdForStore = randomUUID();

    const built = buildArgsForSession({
      tool,
      baseArgs: [],
      profile: effectiveProfile,
      cwd,
    });

    if (wantsToolSession) {
      if (tool === "codex") built.args = [toolAction!, toolSessionId, ...built.args];
      if (tool === "claude") {
        built.args.push("--resume", toolSessionId);
        if (toolAction === "fork") built.args.push("--fork-session");
      }
    } else if (tool === "claude" && toolSessionIdForStore) {
      built.args.push("--session-id", toolSessionIdForStore);
    }

    // OpenCode supports a positional "project" path. Use cwd if provided.
    if (tool === "opencode" && cwd) built.args.unshift(cwd);

    const id = nanoid(12);

    // Claude Code: install PermissionRequest hook (session-local via --settings) so approvals show in Inbox.
    if (tool === "claude" && claudeHooksEnabled && caps.claude.supports.settings) {
      const scriptPath = ensureClaudePermissionHookScript();
      if (scriptPath) {
        const hookKey = nanoid(32);
        claudeHookSessions.set(id, { key: hookKey });
        extraEnv.FYP_HOOK_BASE_URL = hookBaseUrl;
        extraEnv.FYP_HOOK_KEY = hookKey;
        extraEnv.FYP_SESSION_ID = id;
        const cmd = `${shQuote(process.execPath)} ${shQuote(scriptPath)}`;
        const settings = {
          hooks: {
            PermissionRequest: [
              {
                matcher: "*",
                hooks: [{ type: "command", command: cmd, timeout: 600 }],
              },
            ],
          },
        };
        built.args.push("--settings", JSON.stringify(settings));
      }
    }

    const spawnedAt = Date.now();
    try {
      sessions.createSession({ id, tool, profileId, cwd, extraArgs: built.args, env: extraEnv });
    } catch (e: any) {
      claudeHookSessions.delete(id);
      return reply.code(400).send({
        error: "spawn_failed",
        message: typeof e?.message === "string" ? e.message : "failed to spawn tool",
      });
    }

    log("session created", { id, tool, profileId, cwd: cwd ?? null, toolSessionId: toolSessionIdForStore });

    // Persist the session immediately so hook callbacks (Claude) and websockets can
    // associate events with it. Git resolution can be slow; do that async later.
    store.createSession({
      id,
      tool,
      profileId,
      toolSessionId: toolSessionIdForStore,
      cwd: cwd ?? null,
      workspaceKey: null,
      workspaceRoot: null,
      treePath: null,
    });

    if (tool === "codex" && !toolSessionIdForStore && cwd) {
      scheduleCodexToolSessionLink(id, cwd, spawnedAt);
    }

    const createdEventId = store.appendEvent(id, "session.created", {
      tool,
      profileId,
      cwd: cwd ?? null,
      toolAction: wantsToolSession ? toolAction : null,
      toolSessionId: wantsToolSession ? toolSessionId : toolSessionIdForStore,
      args: built.args,
      notes: built.notes,
      overrides: overrides ?? {},
      savePreset,
      workspaceKey: null,
      workspaceRoot: null,
      treePath: null,
    });
    broadcastEvent(id, { id: createdEventId, ts: Date.now(), kind: "session.created", data: { tool, profileId, cwd: cwd ?? null } });
    attachBroadcast(id, tool);
    attachExitTracking(id);
    broadcastGlobal({ type: "sessions.changed" });

    // Save per-workspace defaults (non-permanent tool config; just FYP presets).
    if (cwd && savePreset) {
      try {
        // Write the cwd preset immediately; git-workspace presets are written after resolution.
        store.upsertWorkspacePreset({ path: cwd, tool, profileId, overrides: overrides ?? {} });
        broadcastGlobal({ type: "workspaces.changed" });
      } catch {
        // ignore
      }
    }

    // Resolve git workspace metadata asynchronously (reduces create latency and avoids
    // missing early Claude hook callbacks due to slow git commands).
    if (cwd) {
      void (async () => {
        let workspaceKey: string | null = null;
        let workspaceRoot: string | null = null;
        let treePath: string | null = null;
        try {
          const gr = await resolveGitForPath(cwd);
          if (gr.ok) {
            workspaceKey = gr.workspaceKey;
            workspaceRoot = gr.workspaceRoot;
            treePath = gr.treeRoot;
          }
        } catch {
          // ignore
        }

        if (!workspaceKey && !workspaceRoot && !treePath) return;
        try {
          const cur = store.getSession(id);
          if (!cur) return;
          store.setSessionMeta({
            id,
            workspaceKey,
            workspaceRoot,
            treePath,
            label: cur.label ?? null,
          });
          const evId = store.appendEvent(id, "session.git", { workspaceKey, workspaceRoot, treePath });
          if (evId !== -1) {
            broadcastEvent(id, {
              id: evId,
              ts: Date.now(),
              kind: "session.git",
              data: { workspaceKey, workspaceRoot, treePath },
            });
          }
          broadcastGlobal({ type: "sessions.changed" });
          broadcastGlobal({ type: "workspaces.changed" });

          // Also persist git-workspace presets so worktrees share defaults.
          if (savePreset && workspaceKey) {
            const presetPaths = new Set<string>([workspaceKey]);
            if (workspaceRoot) presetPaths.add(workspaceRoot);
            for (const pp of presetPaths) store.upsertWorkspacePreset({ path: pp, tool, profileId, overrides: overrides ?? {} });
            broadcastGlobal({ type: "workspaces.changed" });
          }
        } catch {
          // ignore
        }
      })();
    }

    if (profile && profile.tool === tool) {
      try {
        const writes = macroToWrites(profile.startup as any);
        for (const w of writes) sessions.write(id, w);
        const evId = store.appendEvent(id, "profile.startup", { profileId });
        broadcastEvent(id, { id: evId, ts: Date.now(), kind: "profile.startup", data: { profileId } });
      } catch {
        const evId = store.appendEvent(id, "profile.startup_failed", { profileId });
        broadcastEvent(id, { id: evId, ts: Date.now(), kind: "profile.startup_failed", data: { profileId } });
      }
    }

    return { id };
  });

  app.get("/api/sessions/:id", async (req, reply) => {
    const id = (req.params as any).id as string;
    const s = store.getSession(id);
    if (!s) return reply.code(404).send({ error: "not found" });
    return {
      ...s,
      status: sessions.getStatus(id) ?? { running: false, pid: null, exitCode: s.exitCode, signal: s.signal },
    };
  });

  app.patch("/api/sessions/:id/meta", async (req, reply) => {
    const id = (req.params as any).id as string;
    const s = store.getSession(id);
    if (!s) return reply.code(404).send({ error: "not found" });
    const body = (req.body ?? {}) as any;

    let label: string | null | undefined = undefined;
    if (body && Object.prototype.hasOwnProperty.call(body, "label")) {
      label = typeof body.label === "string" ? body.label.trim() : null;
      if (label === "") label = null;
    }

    let pinnedSlot: number | null | undefined = undefined;
    if (body && Object.prototype.hasOwnProperty.call(body, "pinnedSlot")) {
      if (body.pinnedSlot == null) pinnedSlot = null;
      else pinnedSlot = Number(body.pinnedSlot);
      if (pinnedSlot != null) {
        if (!Number.isFinite(pinnedSlot) || Math.floor(pinnedSlot) !== pinnedSlot || pinnedSlot < 1 || pinnedSlot > 6) {
          return reply.code(400).send({ error: "bad_pinnedSlot" });
        }
      }
    }

    if (label === undefined && pinnedSlot === undefined) return { ok: true };

    try {
      if (label !== undefined) store.setSessionLabel(id, label);
      if (pinnedSlot !== undefined) store.setSessionPinnedSlot(id, pinnedSlot);
    } catch (e: any) {
      return reply.code(400).send({ error: "update_failed", message: String(e?.message ?? "") });
    }

    const evId = store.appendEvent(id, "session.meta", { label: label ?? undefined, pinnedSlot: pinnedSlot ?? undefined });
    broadcastEvent(id, { id: evId, ts: Date.now(), kind: "session.meta", data: { label, pinnedSlot } });
    broadcastGlobal({ type: "sessions.changed" });
    broadcastGlobal({ type: "workspaces.changed" });
    return { ok: true, event: { id: evId, ts: Date.now(), kind: "session.meta", data: { label, pinnedSlot } } };
  });

  app.post("/api/sessions/:id/input", async (req, reply) => {
    const id = (req.params as any).id as string;
    const body = (req.body ?? {}) as any;
    const text = typeof body.text === "string" ? body.text : "";
    if (!store.getSession(id)) return reply.code(404).send({ error: "not found" });
    const evId = store.appendEvent(id, "input", { text });
    broadcastEvent(id, { id: evId, ts: Date.now(), kind: "input", data: { text } });
    sessions.write(id, text);
    return { ok: true, event: { id: evId, ts: Date.now(), kind: "input", data: { text } } };
  });

  app.post("/api/sessions/:id/interrupt", async (req, reply) => {
    const id = (req.params as any).id as string;
    if (!store.getSession(id)) return reply.code(404).send({ error: "not found" });
    const evId = store.appendEvent(id, "interrupt", {});
    broadcastEvent(id, { id: evId, ts: Date.now(), kind: "interrupt", data: {} });
    sessions.interrupt(id);
    return { ok: true, event: { id: evId, ts: Date.now(), kind: "interrupt", data: {} } };
  });

  app.post("/api/sessions/:id/stop", async (req, reply) => {
    const id = (req.params as any).id as string;
    if (!store.getSession(id)) return reply.code(404).send({ error: "not found" });
    const evId = store.appendEvent(id, "stop", {});
    broadcastEvent(id, { id: evId, ts: Date.now(), kind: "stop", data: {} });
    sessions.stop(id);
    return { ok: true, event: { id: evId, ts: Date.now(), kind: "stop", data: {} } };
  });

  app.post("/api/sessions/:id/kill", async (req, reply) => {
    const id = (req.params as any).id as string;
    if (!store.getSession(id)) return reply.code(404).send({ error: "not found" });
    const evId = store.appendEvent(id, "kill", {});
    broadcastEvent(id, { id: evId, ts: Date.now(), kind: "kill", data: {} });
    sessions.kill(id);
    return { ok: true, event: { id: evId, ts: Date.now(), kind: "kill", data: {} } };
  });

  app.post("/api/sessions/:id/resize", async (req, reply) => {
    const id = (req.params as any).id as string;
    const body = (req.body ?? {}) as any;
    const cols = Number(body.cols);
    const rows = Number(body.rows);
    if (!store.getSession(id)) return reply.code(404).send({ error: "not found" });
    if (!Number.isFinite(cols) || !Number.isFinite(rows)) return reply.code(400).send({ error: "invalid size" });
    sessions.resize(id, cols, rows);
    return { ok: true };
  });

  app.get("/api/sessions/:id/transcript", async (req, reply) => {
    const id = (req.params as any).id as string;
    if (!store.getSession(id)) return reply.code(404).send({ error: "not found" });
    flushOutput(id);
    const q = req.query as any;
    const limit = Math.min(2000, Math.max(50, Number(q?.limit ?? 400)));
    const cursor = Number.isFinite(Number(q?.cursor)) ? Number(q.cursor) : null;
    return store.getTranscript(id, { limit, cursor });
  });

  app.get("/api/sessions/:id/events", async (req, reply) => {
    const id = (req.params as any).id as string;
    if (!store.getSession(id)) return reply.code(404).send({ error: "not found" });
    const q = req.query as any;
    const limit = Math.min(500, Math.max(20, Number(q?.limit ?? 120)));
    const cursor = Number.isFinite(Number(q?.cursor)) ? Number(q.cursor) : null;
    return store.getEvents(id, { limit, cursor });
  });

  app.get("/ws/sessions/:id", { websocket: true }, (socket: WebSocket, req) => {
    const id = (req.params as any).id as string;
    if (!store.getSession(id)) {
      try {
        socket.close();
      } catch {
        // ignore
      }
      return;
    }

    const set = sockets.get(id) ?? new Set<WebSocket>();
    set.add(socket);
    sockets.set(id, set);
    log("ws session open", { sessionId: id, ip: (req as any).ip ?? null });
    wsLog("session open", id);
    socket.on("error", (err: any) => wsLog("session error", id, String(err?.message ?? err)));
    socket.on("close", (code: number, reason: any) =>
      wsLog("session close", id, code, reason && typeof reason.toString === "function" ? reason.toString() : ""),
    );

    // Send a small replay for instant context.
    flushOutput(id);
    const replay = store.getTranscript(id, { limit: 400, cursor: null });
    for (const item of replay.items) wsSend(socket, { type: "output", chunk: item.chunk, ts: item.ts });
    const evReplay = store.getEvents(id, { limit: 120, cursor: null });
    for (const e of evReplay.items) wsSend(socket, { type: "event", event: e });
    const assist = assistState.get(id)?.assist ?? null;
    wsSend(socket, { type: "assist", assist, ts: Date.now() });

    socket.on("message", (raw: any) => {
      try {
        const msg = JSON.parse(raw.toString());
        if (msg?.type === "ping") {
          wsSend(socket, { type: "pong", ts: Date.now(), clientTs: Number(msg.ts ?? 0) || null });
          return;
        }
        if (msg?.type === "input" && typeof msg.text === "string") {
          const evId = store.appendEvent(id, "input", { text: msg.text });
          broadcastEvent(id, { id: evId, ts: Date.now(), kind: "input", data: { text: msg.text } });
          sessions.write(id, msg.text);
        }
        if (msg?.type === "resize" && Number.isFinite(msg.cols) && Number.isFinite(msg.rows)) {
          sessions.resize(id, msg.cols, msg.rows);
        }
        if (msg?.type === "interrupt") {
          const evId = store.appendEvent(id, "interrupt", {});
          broadcastEvent(id, { id: evId, ts: Date.now(), kind: "interrupt", data: {} });
          sessions.interrupt(id);
        }
        if (msg?.type === "stop") {
          const evId = store.appendEvent(id, "stop", {});
          broadcastEvent(id, { id: evId, ts: Date.now(), kind: "stop", data: {} });
          sessions.stop(id);
        }
        if (msg?.type === "kill") {
          const evId = store.appendEvent(id, "kill", {});
          broadcastEvent(id, { id: evId, ts: Date.now(), kind: "kill", data: {} });
          sessions.kill(id);
        }
      } catch {
        // ignore
      }
    });

    socket.on("close", () => {
      const s = sockets.get(id);
      if (!s) return;
      s.delete(socket);
      if (s.size === 0) sockets.delete(id);
      log("ws session close", { sessionId: id, ip: (req as any).ip ?? null });
    });
  });

  app.get("/ws/global", { websocket: true }, (socket: WebSocket) => {
    wsLog("global open");
    globalSockets.add(socket);
    log("ws global open");
    socket.on("error", (err: any) => wsLog("global error", String(err?.message ?? err)));
    // Lightweight initial sync. UI can fetch details via HTTP.
    wsSend(socket, { type: "sessions.changed" });
    wsSend(socket, { type: "workspaces.changed" });
    wsSend(socket, { type: "inbox.changed" });
    socket.on("message", (raw: any) => {
      try {
        const msg = JSON.parse(raw.toString());
        if (msg?.type === "ping") wsSend(socket, { type: "pong", ts: Date.now(), clientTs: Number(msg.ts ?? 0) || null });
      } catch {
        // ignore
      }
    });
    socket.on("close", () => {
      wsLog("global close");
      globalSockets.delete(socket);
      log("ws global close");
    });
  });

  app.addHook("onClose", async () => {
    for (const sid of outputBuf.keys()) flushOutput(sid);
    sessions.dispose();
    store.close();
  });

  return app;
}
